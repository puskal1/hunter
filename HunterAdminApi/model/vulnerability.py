#!/ usr/bin/env
# coding=utf-8
#
# Copyright 2019 ztosec & https://www.zto.com/
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
"""
author: b5mali4
"""
import json
from peewee import *
import datetime

from model.task import Task
from model.hunter_model import HunterModel, HunterModelService
from common.config_util import get_system_config
from common.mysql_util import MysqlManage


class Vulnerability(HunterModel):
    """
    info: 为该漏洞的信息
    path: 该插件的实际位置(保留，用于验证)
    payload: payload
    imp_version: 影响版本
    error:错误日志
    repair: 修复建议
    type:漏洞类型  'cors',
    chinese_type: 中文漏洞类型 请求对象共享
    description: 漏洞详情 由于配置不当，导致可以通过设置Origin来控制Access-Control-Allow-Methods,参考链接http://www.freebuf.com/articles/web/18493.html
    level:等级 middle
    origin_data: 请求原始数据，可用于后台数据包支持重放功能
    """
    # task = ForeignKeyField(Task, backref='vulns')
    url_id = IntegerField(null=True)  # 不一定能关联到
    task_id = IntegerField(null=True)  # 关联任务id
    info = TextField(null=True)
    plugin_info = TextField(null=True)  # 插件信息，用于反向定位插件
    payload = TextField(null=True)
    imp_version = TextField(null=True)
    error = TextField(null=True)
    repair = TextField(null=True)
    type = TextField(null=True)
    chinese_type = TextField(null=True)
    description = TextField(null=True)
    level = TextField(null=True)
    origin_data = TextField(null=True)

    class Meta:
        database = MysqlManage.get_database()


class VulnerabilityService:
    """
    对Vulnerability表进行CURD操作
    """

    @staticmethod
    def get_fields_by_where(**kwargs):
        """
        To use:
        >>> vulns = VulnerabilityService.get_fields_by_where(fields=(User.full_name), where=(User.mobile_phone == "122222"))
        >>> print(vulns)
        :param kwargs: 
        :return: 
        """
        return HunterModelService.get_fields_by_where(Vulnerability, **kwargs)

    @staticmethod
    def count(**kwargs):
        """
        数据数量
        To use:
        >>> VulnerabilityService.count(where=(Vulnerability.id == 1))
        :param kwargs: 
        :return: 
        """
        return HunterModelService.count(Vulnerability, **kwargs)

    @staticmethod
    def update(**kwargs):
        """
        更新操作，更新操作之后
        To use:
        >>> VulnerabilityService.update(fields=({Vulnerability.level: VulnLevel.HIGHT }))
        :param kwargs: 
        :return: 
        """
        return HunterModelService.update(Vulnerability, **kwargs)

    @staticmethod
    def save(**kwargs):
        """
        保存漏洞信息
        To use:
        >>> VulnerabilityService.save(url_id=url.id, task_id=task_id, info=result['info'], plugin_info=None,
        >>>                           payload=result["payload"],
        >>>                           imp_version=result['details']['imp_version'], error=''.join(result['error']),
        >>>                           repair=result['details']['repair'], type=result['details']['type']['fullname'],
        >>>                           chinese_type=result['details']['type']['fullchinesename'],
        >>>                           description=result['details']['description'],
        >>>                           level=result['details']['type']['level'],
        >>>                           origin_data=None)
        :param url_id: 
        :param task_id: 
        :param result: 
        :return: 
        """

        return HunterModelService.save(Vulnerability, **kwargs)

    @staticmethod
    def get_vulnerabilitys_nltdr(task_id):
        """
        根据任务id来组合获得 数量，等级，类型，创建者
        :param task_id: 
        :return:     
        """

        vuls_detail = list()

        vul_level = {'high': 0, 'middle': 0, 'low': 0}

        vul_type = {'sql_inject': 0, 'xss': 0, 'xxe': 0, 'weak_pwd': 0, 'cmdect': 0, 'file_read': 0, 'file_upload': 0,
                    'file_include': 0, 'ddos': 0, 'csrf': 0,
                    'cors': 0, 'jsonp': 0, 'info_leak': 0, 'crlf': 0, 'other': 0, 'hidden_danger': 0, 'ssrf': 0}
        vulnerabilitys = VulnerabilityService.get_fields_by_where(where=(Vulnerability.task_id == task_id))
        # print(vulnerabilitys)

        for vulnerability in vulnerabilitys:
            vul_level[vulnerability.level] += 1
            vul_type[vulnerability.type] += 1
            vulnerability.payload = vulnerability.payload.replace('"', "'")
            try:
                # {转码会有问题
                vuls_detail.append(
                    json.loads(str(vulnerability).replace("\\n", "").encode("utf-8").decode("unicode_escape")))
            except json.decoder.JSONDecodeError:
                print(str(vulnerability))
                print(str(vulnerability).replace("\\n", ""))
        if vul_level["high"] > 0:
            risk_level = "high"
        elif vul_level["middle"] > 0:
            risk_level = "middle"
        elif vul_level["low"] > 0:
            risk_level = "low"
        else:
            risk_level = "safe"

        return {'num': len(vuls_detail), 'level': vul_level, 'type': vul_type, 'details': vuls_detail,
                'risk_level': risk_level}
    
    @staticmethod
    def get_risk_level(task):
        """
        获取风险等级
        :param task: 
        :return: 
        """
        risk_level = "safe"
        if task.vulns_num > 0:
            if int(task.middle_vulns_num) > 0:
                risk_level = "high"
            elif int(task.high_vulns_num) > 0:
                risk_level = "middle"
            elif int(task.low_vulns_num) > 0:
                risk_level = "low"
        return risk_level
    
    @staticmethod
    @MysqlManage.close_database
    def get_vulnerabilitys_nlt(task_id):
        """
        根据任务id来组合获得 数量，等级，类型
        SELECT COUNT(*)	AS	`num`,SUM(if(`level` = 'high', 1, 0)) AS hight,SUM(if(`level` = 'low', 1, 0)) AS low,SUM(if(`level` = 'middle', 1, 0)) AS middle,	SUM(if(`type` = 'sql_inject', 1, 0)) AS sql_inject,	SUM(if(`type` = 'xss', 1, 0)) AS xss,	SUM(if(`type` = 'xxe', 1, 0)) AS xxe,	SUM(if(`type` = 'weak_pwd', 1, 0)) AS weak_pwd,	SUM(if(`type` = 'cmdect', 1, 0)) AS cmdect,	SUM(if(`type` = 'file_read', 1, 0)) AS file_read,	SUM(if(`type` = 'file_upload', 1, 0)) AS file_upload,	SUM(if(`type` = 'file_include', 1, 0)) AS file_include,	SUM(if(`type` = 'ddos', 1, 0)) AS ddos, SUM(if(`type` = 'csrf', 1, 0)) AS csrf,	SUM(if(`type` = 'cors', 1, 0)) AS cors, SUM(if(`type` = 'jsonp', 1, 0)) AS jsonp,	SUM(if(`type` = 'info_leak', 1, 0)) AS info_leak,	SUM(if(`type` = 'crlf', 1, 0)) AS crlf,	SUM(if(`type` = 'other', 1, 0)) AS other,	SUM(if(`type` = 'hidden_danger', 1, 0)) AS hidden_danger
FROM `vulnerability` AS vulnerability WHERE (vulnerability.`task_id` = 3)
        
        :param task_id: 
        :return: 
        """
        vuln_nlt = Vulnerability.select(fn.COUNT(Vulnerability.id).alias('num'),
                                        fn.SUM(fn.IF(Vulnerability.level == "high", 1, 0)).alias('high'),
                                        fn.SUM(fn.IF(Vulnerability.level == "middle", 1, 0)).alias('middle'),
                                        fn.SUM(fn.IF(Vulnerability.level == "low", 1, 0)).alias('low'),
                                        fn.SUM(fn.IF(Vulnerability.type == "sql_inject", 1, 0)).alias('sql_inject'),
                                        fn.SUM(fn.IF(Vulnerability.type == "xss", 1, 0)).alias('xss'),
                                        fn.SUM(fn.IF(Vulnerability.type == "xxe", 1, 0)).alias('xxe'),
                                        fn.SUM(fn.IF(Vulnerability.type == "weak_pwd", 1, 0)).alias('weak_pwd'),
                                        fn.SUM(fn.IF(Vulnerability.type == "cmdect", 1, 0)).alias('cmdect'),
                                        fn.SUM(fn.IF(Vulnerability.type == "file_read", 1, 0)).alias('file_read'),
                                        fn.SUM(fn.IF(Vulnerability.type == "file_upload", 1, 0)).alias('file_upload'),
                                        fn.SUM(fn.IF(Vulnerability.type == "file_include", 1, 0)).alias('file_include'),
                                        fn.SUM(fn.IF(Vulnerability.type == "ddos", 1, 0)).alias('ddos'),
                                        fn.SUM(fn.IF(Vulnerability.type == "csrf", 1, 0)).alias('csrf'),
                                        fn.SUM(fn.IF(Vulnerability.type == "cors", 1, 0)).alias('cors'),
                                        fn.SUM(fn.IF(Vulnerability.type == "jsonp", 1, 0)).alias('jsonp'),
                                        fn.SUM(fn.IF(Vulnerability.type == "info_leak", 1, 0)).alias('info_leak'),
                                        fn.SUM(fn.IF(Vulnerability.type == "crlf", 1, 0)).alias('crlf'),
                                        fn.SUM(fn.IF(Vulnerability.type == "other", 1, 0)).alias('other'),
                                        fn.SUM(fn.IF(Vulnerability.type == "hidden_danger", 1, 0)).alias(
                                            'hidden_danger')).where(
            Vulnerability.task_id == task_id).execute()[0]

        if vuln_nlt.num > 0:
            if int(vuln_nlt.high) > 0:
                risk_level = "high"
            elif int(vuln_nlt.middle) > 0:
                risk_level = "middle"
            elif int(vuln_nlt.low) > 0:
                risk_level = "low"
            else:
                risk_level = "safe"
        else:
            vul_level = {'high': 0, 'middle': 0, 'low': 0}

            vul_type = {'sql_inject': 0, 'xss': 0, 'xxe': 0, 'weak_pwd': 0, 'cmdect': 0, 'file_read': 0,
                        'file_upload': 0,
                        'file_include': 0, 'ddos': 0, 'csrf': 0,
                        'cors': 0, 'jsonp': 0, 'info_leak': 0, 'crlf': 0, 'other': 0, 'hidden_danger': 0}
            return {'num': 0, 'level': vul_level, 'type': vul_type, 'risk_level': "safe"}

        return {"num": vuln_nlt.num,
                "level": {"high": int(vuln_nlt.high), "middle": int(vuln_nlt.middle), "low": int(vuln_nlt.low)},
                'type': {"sql_inject": int(vuln_nlt.sql_inject), "xss": int(vuln_nlt.xss), "xxe": int(vuln_nlt.xxe),
                         "weak_pwd": int(vuln_nlt.weak_pwd), "cmdect": int(vuln_nlt.cmdect),
                         "file_read": int(vuln_nlt.file_read),
                         "file_upload": int(vuln_nlt.file_upload), "file_include": int(vuln_nlt.file_include),
                         "ddos": int(vuln_nlt.ddos), "csrf": int(vuln_nlt.csrf), "cors": int(vuln_nlt.cors),
                         "jsonp": int(vuln_nlt.jsonp),
                         "info_leak": int(vuln_nlt.info_leak), "crlf": int(vuln_nlt.crlf), "other": int(vuln_nlt.other),
                         "hidden_danger": int(vuln_nlt.hidden_danger)}, 'risk_level': risk_level}

    @staticmethod
    @MysqlManage.close_database
    def get_vulnerability_count(user_id=None):
        """
        根据用户的username来查询得到该用户历史记录上所有漏洞的类型和等级的数量
        SELECT * FROM vulnerability INNER JOIN usertask ON usertask.task_id = vulnerability.task_id where usertask.user_id='1222'
        :param username: 
        :return: 
        """
        from model.user_task import UserTask

        level_dict = {'high': 0, 'middle': 0, 'low': 0}

        type_dict = {'sql_inject': 0, 'xss': 0, 'xxe': 0, 'weak_pwd': 0, 'cmdect': 0, 'file_read': 0,
                     'file_upload': 0,
                     'file_include': 0, 'ddos': 0, 'csrf': 0,
                     'cors': 0, 'jsonp': 0, 'info_leak': 0, 'crlf': 0, 'other': 0, 'hidden_danger': 0}
        if user_id:
            # vulnerabilitys = Vulnerability.select().join(UserTask, JOIN.INNER, on=(Vulnerability.task_id == UserTask.task_id)).where(UserTask.user_id == user_id).execute()
            vuln_nlt = Vulnerability.select(fn.COUNT(Vulnerability.id).alias('num'),
                                            fn.SUM(fn.IF(Vulnerability.level == "high", 1, 0)).alias('high'),
                                            fn.SUM(fn.IF(Vulnerability.level == "middle", 1, 0)).alias('middle'),
                                            fn.SUM(fn.IF(Vulnerability.level == "low", 1, 0)).alias('low'),
                                            fn.SUM(fn.IF(Vulnerability.type == "sql_inject", 1, 0)).alias('sql_inject'),
                                            fn.SUM(fn.IF(Vulnerability.type == "xss", 1, 0)).alias('xss'),
                                            fn.SUM(fn.IF(Vulnerability.type == "xxe", 1, 0)).alias('xxe'),
                                            fn.SUM(fn.IF(Vulnerability.type == "weak_pwd", 1, 0)).alias('weak_pwd'),
                                            fn.SUM(fn.IF(Vulnerability.type == "cmdect", 1, 0)).alias('cmdect'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_read", 1, 0)).alias('file_read'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_upload", 1, 0)).alias(
                                                'file_upload'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_include", 1, 0)).alias(
                                                'file_include'),
                                            fn.SUM(fn.IF(Vulnerability.type == "ddos", 1, 0)).alias('ddos'),
                                            fn.SUM(fn.IF(Vulnerability.type == "csrf", 1, 0)).alias('csrf'),
                                            fn.SUM(fn.IF(Vulnerability.type == "cors", 1, 0)).alias('cors'),
                                            fn.SUM(fn.IF(Vulnerability.type == "jsonp", 1, 0)).alias('jsonp'),
                                            fn.SUM(fn.IF(Vulnerability.type == "info_leak", 1, 0)).alias('info_leak'),
                                            fn.SUM(fn.IF(Vulnerability.type == "crlf", 1, 0)).alias('crlf'),
                                            fn.SUM(fn.IF(Vulnerability.type == "other", 1, 0)).alias('other'),
                                            fn.SUM(fn.IF(Vulnerability.type == "hidden_danger", 1, 0)).alias(
                                                'hidden_danger')).join(UserTask, JOIN.INNER, on=(
                Vulnerability.task_id == UserTask.task_id)).where(UserTask.user_id == user_id).execute()[0]
        else:
            vuln_nlt = Vulnerability.select(fn.COUNT(Vulnerability.id).alias('num'),
                                            fn.SUM(fn.IF(Vulnerability.level == "high", 1, 0)).alias('high'),
                                            fn.SUM(fn.IF(Vulnerability.level == "middle", 1, 0)).alias('middle'),
                                            fn.SUM(fn.IF(Vulnerability.level == "low", 1, 0)).alias('low'),
                                            fn.SUM(fn.IF(Vulnerability.type == "sql_inject", 1, 0)).alias('sql_inject'),
                                            fn.SUM(fn.IF(Vulnerability.type == "xss", 1, 0)).alias('xss'),
                                            fn.SUM(fn.IF(Vulnerability.type == "xxe", 1, 0)).alias('xxe'),
                                            fn.SUM(fn.IF(Vulnerability.type == "weak_pwd", 1, 0)).alias('weak_pwd'),
                                            fn.SUM(fn.IF(Vulnerability.type == "cmdect", 1, 0)).alias('cmdect'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_read", 1, 0)).alias('file_read'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_upload", 1, 0)).alias(
                                                'file_upload'),
                                            fn.SUM(fn.IF(Vulnerability.type == "file_include", 1, 0)).alias(
                                                'file_include'),
                                            fn.SUM(fn.IF(Vulnerability.type == "ddos", 1, 0)).alias('ddos'),
                                            fn.SUM(fn.IF(Vulnerability.type == "csrf", 1, 0)).alias('csrf'),
                                            fn.SUM(fn.IF(Vulnerability.type == "cors", 1, 0)).alias('cors'),
                                            fn.SUM(fn.IF(Vulnerability.type == "jsonp", 1, 0)).alias('jsonp'),
                                            fn.SUM(fn.IF(Vulnerability.type == "info_leak", 1, 0)).alias('info_leak'),
                                            fn.SUM(fn.IF(Vulnerability.type == "crlf", 1, 0)).alias('crlf'),
                                            fn.SUM(fn.IF(Vulnerability.type == "other", 1, 0)).alias('other'),
                                            fn.SUM(fn.IF(Vulnerability.type == "hidden_danger", 1, 0)).alias(
                                                'hidden_danger')).execute()[0]
        if vuln_nlt.num > 0:
            return {"level": {"high": int(vuln_nlt.high), "middle": int(vuln_nlt.middle), "low": int(vuln_nlt.low)},
                    'type': {"sql_inject": int(vuln_nlt.sql_inject), "xss": int(vuln_nlt.xss), "xxe": int(vuln_nlt.xxe),
                             "weak_pwd": int(vuln_nlt.weak_pwd), "cmdect": int(vuln_nlt.cmdect),
                             "file_read": int(vuln_nlt.file_read),
                             "file_upload": int(vuln_nlt.file_upload), "file_include": int(vuln_nlt.file_include),
                             "ddos": int(vuln_nlt.ddos), "csrf": int(vuln_nlt.csrf), "cors": int(vuln_nlt.cors),
                             "jsonp": int(vuln_nlt.jsonp),
                             "info_leak": int(vuln_nlt.info_leak), "crlf": int(vuln_nlt.crlf),
                             "other": int(vuln_nlt.other),
                             "hidden_danger": int(vuln_nlt.hidden_danger)}}
        else:
            return {"level": level_dict, "type": type_dict}

    @staticmethod
    @MysqlManage.close_database
    def get_vulnerability_count_bak(user_id=None):
        """
        根据用户的username来查询得到该用户历史记录上所有漏洞的类型和等级的数量
        SELECT * FROM vulnerability INNER JOIN usertask ON usertask.task_id = vulnerability.task_id where usertask.user_id='1222'
        :param username: 
        :return: 
        """
        from model.user_task import UserTask

        level_dict = {'high': 0, 'middle': 0, 'low': 0}

        type_dict = {'sql_inject': 0, 'xss': 0, 'xxe': 0, 'weak_pwd': 0, 'cmdect': 0, 'file_read': 0,
                     'file_upload': 0,
                     'file_include': 0, 'ddos': 0, 'csrf': 0,
                     'cors': 0, 'jsonp': 0, 'info_leak': 0, 'crlf': 0, 'other': 0, 'hidden_danger': 0}
        if user_id:
            vulnerabilitys = Vulnerability.select().join(UserTask, JOIN.INNER,
                                                         on=(Vulnerability.task_id == UserTask.task_id)).where(
                UserTask.user_id == user_id).execute()
        else:
            vulnerabilitys = Vulnerability.select().execute()
        for vulnerability in vulnerabilitys:
            vul_level = vulnerability.level
            vul_type = vulnerability.type
            level_dict[vul_level] += 1
            type_dict[vul_type] += 1

        return {"level": level_dict, "type": type_dict}

    @staticmethod
    @MysqlManage.close_database
    def get_tasks_urls_vulns_num_by_days(user_id=None, day_range=None):
        """
        A情况:day_range传入,user_id不传入	
        sql语句:SELECT *,(SELECT COUNT(*) FROM url WHERE url.task_id=task.id) AS url_num,(SELECT COUNT(*) FROM vulnerability WHERE vulnerability.task_id=task.id) AS vuln_num FROM task WHERE task.created_time > '1745-11-15'
        
        B情况:day_range传入,user_id传入
        sql语句:SELECT *,(SELECT COUNT(*) FROM url WHERE url.task_id=task.id) AS url_num,(SELECT COUNT(*) FROM vulnerability WHERE vulnerability.task_id=task.id) AS vuln_num FROM task INNER JOIN usertask ON task.id = usertask.task_id WHERE task.created_time >= '1745-11-15' AND usertask.user_id = 1
        
        C情况:day_range不传入,user_id不传入
        sql语句:SELECT *,(SELECT COUNT(*) FROM url WHERE url.task_id=task.id) AS url_num,(SELECT COUNT(*) FROM vulnerability WHERE vulnerability.task_id=task.id) AS vuln_num FROM task
        
        D情况:day_range不传入,user_id传入
        sql语句:SELECT *,(SELECT COUNT(*) FROM url WHERE url.task_id=task.id) AS url_num,(SELECT COUNT(*) FROM vulnerability WHERE vulnerability.task_id=task.id) AS vuln_num FROM task INNER JOIN usertask ON task.id = usertask.task_id WHERE usertask.user_id = 1
    
        统计最近几天内的任务，url，漏洞数量
        SELECT * FROM task  WHERE DATE_SUB(CURDATE(), INTERVAL 10 DAY) <= created_time
    
        SELECT * FROM task INNER JOIN usertask ON usertask.task_id = task.id where usertask.user_id='1222'
        :param user_id: 
        :param day: 
        :return: 
        """
        from model.task import TaskService, Task
        from model.user_task import UserTask, UserTaskService
        from model.url import Url, UrlService
        from common.system_util import get_front_date
        from common.json_utils import dict_auto_add

        created_date2task_num = dict()
        created_date2urls_num = dict()
        created_date2vulns_num = dict()

        if user_id:
            task_total_num = TaskService.count(where=(Task.create_user_id == user_id))
            url_total_num = Url.select(fn.COUNT(Url.id).alias('urls_total_num')).join(UserTask, JOIN.INNER, on=(
                UserTask.task_id == Url.task_id)).where(UserTask.user_id == user_id).execute()[0].urls_total_num
            vuln_total_num = \
                Vulnerability.select(fn.COUNT(Vulnerability.id).alias('vulns_total_num')).join(UserTask, JOIN.INNER,
                                                                                               on=(
                                                                                                   UserTask.task_id == Vulnerability.task_id)).where(
                    UserTask.user_id == user_id).execute()[0].vulns_total_num
        else:
            task_total_num = TaskService.count()
            url_total_num = UrlService.count()
            vuln_total_num = VulnerabilityService.count()

        if day_range:
            front_date = get_front_date(day_range=day_range)
            if not user_id:  # 情况A
                matched_tasks = Task.select(Task.id, Task.created_time,
                                            Url.select(fn.COUNT(Url.id)).alias('urls_num').where(
                                                Url.task_id == Task.id),
                                            Vulnerability.select(fn.COUNT(Vulnerability.id)).alias(
                                                'vulns_num').where(
                                                Vulnerability.task_id == Task.id)).where(
                    Task.created_time >= front_date).execute()
            else:  # 情况B
                matched_tasks = Task.select(Task.id, Task.created_time,
                                            Url.select(fn.COUNT(Url.id)).alias('urls_num').where(
                                                Url.task_id == Task.id),
                                            Vulnerability.select(fn.COUNT(Vulnerability.id)).alias(
                                                'vulns_num').where(
                                                Vulnerability.task_id == Task.id)).join(UserTask, JOIN.INNER, on=(
                    Task.id == UserTask.task_id)).where(Task.created_time >= front_date,
                                                        UserTask.user_id == user_id).execute()
        else:
            if not user_id:  # 情况C
                matched_tasks = Task.select(Task.id, Task.created_time,
                                            Url.select(fn.COUNT(Url.id)).alias('urls_num').where(
                                                Url.task_id == Task.id),
                                            Vulnerability.select(fn.COUNT(Vulnerability.id)).alias(
                                                'vulns_num').where(
                                                Vulnerability.task_id == Task.id)).execute()
            else:  # 情况D
                matched_tasks = Task.select(Task.id, Task.created_time,
                                            Url.select(fn.COUNT(Url.id)).alias('urls_num').where(
                                                Url.task_id == Task.id),
                                            Vulnerability.select(fn.COUNT(Vulnerability.id)).alias(
                                                'vulns_num').where(
                                                Vulnerability.task_id == Task.id)).join(UserTask, JOIN.INNER, on=(
                    Task.id == UserTask.task_id, UserTask.user_id == user_id)).execute()

        for matched_task in matched_tasks:
            create_day = str(matched_task.created_time).split(" ")[0]
            dict_auto_add(created_date2task_num, create_day)
            dict_auto_add(created_date2urls_num, create_day, matched_task.urls_num)
            dict_auto_add(created_date2vulns_num, create_day, matched_task.vulns_num)

        return {"task": created_date2task_num, "task_total_num": task_total_num, "url": created_date2urls_num,
                "url_total_num": url_total_num, "vuln": created_date2vulns_num, "vuln_total_num": vuln_total_num}

